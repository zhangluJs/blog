#### JS

# 时间复杂度计算

时间复杂度可以理解为是一个函数，用大写的O表示，比如O(n)、O(1)、O(logN)...

描述该算法大概的运行时间的趋势

O(n2) > O(n) > O(logN) > O(1)

```js
// 时间负责度为 O(1)
/**
 * 为什么下面这两行代码的时间复杂度为 O(1)?
 * 
 * 是因为这两行代码只会被执行一次
 */
let i = 0;
i += 1;
```

```js
// 时间复杂度为 O(n)
/**
 * 为什么下面这两行代码的时间复杂度为 O(n)?
 * 
 * 是因为下面这行代码执行了n次，随着n的增大，执行次数也会增大
 */
for (let i = 0; i < n; i++) {
    console.log(i);
}
```

计算时间复杂度的时候，如果两个时间复杂度先后排列，就把它们相加，而且要取最大的增长更快的时间复杂度。看下面代码

> 相乘与相加是不一样的，相加会忽略增长趋势较小的复杂度，取增加趋势较快的复杂度。

```js
// O(1) + O(n) = O(n);

// O(1)
let i = 0;
i += 1;
// O(n)
for (let i = 0; i < n; i++) {
    console.log(i);
}
```

```js
// 注意这里是相乘
// 时间复杂度为 O(n) * O(n) = O(n2)
for (let i = 0; i < n; i++) {
    for (let j = 0; j < n; j++) {
        onsole.log(i, j);
    }
}
```

```js
// O(logN)
let i = 1;
while(i < n) {
    console.log(i);
    i *= 2;
}
```

# 空间复杂度计算

和时间复杂度一样也是这样表示。一个函数，用大写的O表示，比如O(n)、O(1)、O(n^2)...

算法在运行过程中临时占用存储空间大小的量度

```js
// O(1)
/**
 * 为什么下面这两行代码的空间复杂度为 O(n)?
 * 
 * 因为它只声明了单个变量，单个变量占用的内存永远是1，恒定的
 */
let i = 0;
i += 1;
```

```js
// 空间复杂度为O(n)
/**
 * 为什么下面这两行代码的空间复杂度为 O(n)?
 * 
 * 因为它声明了list的数组，它要添加N个值。相当于占用了N个单元，所以就是O(n)
 */
const list = []
for (let i = 0; i < n; i++) {
    list.push(i);
}
```

```js
// 空间复杂度为O(n^2)
/**
 * 为什么下面这两行代码的空间复杂度为 O(n^2)?
 * 
 * 因为它声明了list的数组，它要添加N个值。相当于占用了N个单元，所以就是O(n)
 */
const list = []
for (let i = 0; i < n; i++) {
    list.push([]);
    for (let j = 0; j < n; j++) {
        list[i].push(j);
    }
}
```

总结一下时间复杂度和空间复杂度：大白话就是执行一次的就是O(1)、套循环的就是O(n)、嵌套就是O(n^*)、非嵌套大的覆盖小的。


# 栈

在javascript中可以用数组来表示栈。栈是一个后进先出的数据结构。可以用数组的 push、pop表示。

```js
let stack = [];
stack.push(1);
stack.push(2); // 后进
stack.pop();   // 2 先出
stack.pop();   // 1
```

# 队列

一个先进先出的数据结构。依然可以用数组来表示队列。

比如js异步中的任务队列

```js
let queue = [];
queue.push(1); // 先进
queue.push(2);
queue.shift(); // 1 先出
queue.shift(); // 2
```

# 链表

多个元素组成的列表。

元素存储不连续，用next指针连在一起。

* 数组 VS 链表

数组：增删非首尾元素时，往往需要移动元素。

链表：增删非首尾元素时，不需要移动元素，只需要更改next指针。

链表的操作其实就是改变指针，可以简单理解为重新给属性赋值的过程。

```js
let a = {val: 'a'};
let b = {val: 'b'};
let c = {val: 'c'};
a.next = b;
b.next = c;

// 遍历链表
let d = a;
while(d) {
    console.log(d.val);
    d = d.next; 
}

// 添加节点  b 和 c中间添加e
let e = {val: 'e'};
b.next = e;
e.next = c;

// 删除节点 e
b.next = c;
```
